# Static Library

### **prog.vala** <a id="blob-path"></a>

```csharp
class MainApp : Object {
    public static int main(string[] args) {
        var l = new LibraryObject();
        l.func();
        return 0;
    }
}
```

### **mylib.vala** <a id="blob-path"></a>

```csharp
public class LibraryObject : Object {
    public void func() {
       stdout.printf("Method in library called.");
    }
}
```

### **meson.build** <a id="blob-path"></a>

```csharp
project('valastatic', 'vala', 'c')
#Список зависимостей, glib это vala std
valadeps = [dependency('glib-2.0'), dependency('gobject-2.0')]
#Объявление статической библиотеки
l = static_library('valalib', 'mylib.vala', dependencies : valadeps)
m = static_library('extractedlib',
  objects : l.extract_all_objects(),
  install : true)
#Скомпилировать исполнительный файл с библиотекой
e = executable('valaprog', 'prog.vala',
link_with : l,
dependencies : valadeps)

test('valastatictest', e)
```

### Object files

Иногда вы не можете создавать файлы из источников, но вам нужно использовать существующий объектный файл. Типичный случай - использование объектного файла, предоставленного третьей стороной. Объектные файлы могут быть указаны следующим образом:

```text
exe = executable('myexe', 'source.cpp', objects : 'third_party_object.o')
```

В коде основного примера можно увидеть объект m который отвечает как раз за вывод экспорт объектных файлов в build директорию.

{% hint style="warning" %}
Очевидно строки с 6 по 8 необязательны
{% endhint %}

Другой случай - это когда вы хотите использовать объектные файлы, встроенные в один целевой объект непосредственно в другом. Типичный случай-это когда вы создаете общую библиотеку и у нее есть внутренний класс, который не экспортируется в ABI. Это означает, что вы не можете получить доступ к нему, даже если вы связываетесь с библиотекой. Типичные обходные пути для этого включают создание как динамической, так и статической версии библиотеки или размещение исходного файла в списке источников тестового исполняемого файла. Оба этих подхода приводят к тому, что источник строится дважды, что является **замедляет процесс сборки**.

В Meson вы можете извлекать объектные файлы из целевых объектов и использовать их как есть на других целевых объектах. Это и есть синтаксис для него.

```csharp
lib = shared_library('somelib', 'internalclass.vala', 'file.vala', ...)
eo = lib.extract_objects('internalclass.vala')
executable('classtest', 'classtest.vala', objects : eo)
```

Здесь мы берем внутренний объект класса и используем его непосредственно в тесте. Исходный файл компилируется только один раз.

Обратите внимание, что неосторожное использование этой функции может вызвать странные ошибки. Например, попытка использовать объекты исполняемой или статической библиотеки в динамической библиотеке не будет работать, поскольку объекты динамической библиотеки требуют специальных флагов компилятора. Получение этого права является ответственностью пользователя. По этой причине настоятельно рекомендуется использовать эту функцию только для создания исполняемых файлов модульного теста таким образом, как описано выше.

